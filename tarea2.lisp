(defun ElemInPos (elemento lista pos)
  (cond ((equal elemento (nth (- pos 1) lista)) T)
	(T NIL)))

(defun Inicia-en (lista elem) 
   (let ( (copia '()) (flag NIL))
      (dolist (i lista (reverse copia)) 
        (cond ((equal flag T) (setq copia (cons i copia)) )
	   ((AND (equal i elem) (equal flag NIL)) (setq flag T copia (list i)))
	     ))))

(defun Termina-en (lista elem) 
  (let ((copia '()) (flag 0))
    (dolist (i lista (reverse copia))
      (cond ((AND (equal i elem) (equal flag 0))(setq flag 1 copia (cons i copia)))
	    ((equal flag 0) (print elem)(setq copia (cons i copia)))
      )
    )
  )
)

(defun Primer-impar (lista)
  (do ((index 0 (+ index 1))) 
     ((oddp (nth index lista)) (list (nth index lista) index)) 
  )
)

(defun Ultimo-elemento (lista)
  (let ((elemento nil) (conteo 0))
    (do ((index (- (length lista) 1) (- index 1)))
	((< index 0) (list elemento conteo))
	(cond ((and (realp elemento) (equal elemento (nth index lista)))
	      (setq conteo (+ conteo 1)))
	      ((and (realp (nth index lista)) (equal elemento nil)) 
	        (setq elemento (nth  index lista) conteo 1))
	)
    )
  )
)

(defun Conteo(lista)
  (let ((lis 0) (num 0))
    (dolist (i lista (cons num lis))
      (cond ((listp i) (setq lis (+ lis 1)) )
	    ((numberp i)(setq num (+ num 1)))
      )
    )
  )
)

(defun Aplana (lista)
  (let ((copia '()) )
    (do ((flag T))
      ((equal flag nil) lista)
      (setq flag nil)
      (dolist (i lista copia)
	(cond ((listp i)(setq flag T copia (append copia i)))
	      (T (setq copia (append copia (list i))))
	)
      )
      (setq lista copia copia '())
    )
  )
)

(defun Diagonal (lista)
  (let ((diag '()) (index 0))
    (dolist (i lista (reverse diag))
      (setq diag (cons (nth index i) diag)
	    index (+ index 1)
      )
    )
  )
)

(defun Elementos (lista)
  (let ((nueva '()))
    (dolist (i lista (reverse nueva))
      (cond ((and (listp i) (null i)) (setq nueva (cons 'N nueva)))
	    ((listp i) (setq nueva (cons 'L nueva)))
	    ((atom i) (setq nueva (cons 'A nueva)))
      )  
    )
  )
)

(defun SumaNumerica (lista) 
  (let ((acum 0))
    (dolist (i lista acum)
      (cond ((numberp i) (setq acum (+ acum i)))
      )
    )
  )
)

(defun FiltraVocales (lista)
  (let ( (nueva '()) )
    (labels ( (deep0 (l1) (dolist (i l1 (reverse nueva))
		  (cond ((listp i) (deep1 i))
		    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
              	     (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
		     (equal #\U i)  (equal #\u i))) (setq nueva (cons i nueva)))
		    )))
	     (deep1 (l2) (dolist (i l2 nueva)
		  (cond ((listp i) (deep2 i))
		    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
              	     (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
		     (equal #\U i)  (equal #\u i))) (setq nueva (cons i nueva)))
		    )))
	     (deep2 (l3) (dolist (i l3 nueva)
		  (cond ((listp i) (setq nueva (cons i nueva)))
		    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
              	     (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
		     (equal #\U i)  (equal #\u i))) (setq nueva (cons i nueva)))
		    )))
   ) (deep0 lista))
  )
)

(defun FiltroMultiplos (lista multi)
  (let ((copia '()))
    (dolist (i lista (reverse copia))
      (cond ((AND (numberp i) (NOT (= (mod i multi) 0))) (setq copia (cons i copia)))
      )
    )
  )
)


(defun Celdas (lista)
  (let ((cola '()) (actual nil) (contador 0) )
    (setq cola (cons lista cola)) ;;meter primer elemento
    
    (do ()
  	((null cola) contador)
        (setq actual (first (last  cola)) cola (butlast cola))
        (dolist (i actual actual)
	  (cond ((listp i) (setq cola (cons i cola))))
	)
        (setq contador (+ contador (length actual)))
    )
  )
)

(defun Implicacion (&rest lista)
  (let ((result T))
    (cond ((= (length lista) 0) nil)
      (t (dolist (i lista result)
	   (cond ( (AND (not (null result))(null i)) (setq result nil) )
		 ( T (setq result T) )
	   )
	 )
      )
    )
  )
)

(defun Mult (li1 li2)
  (let ((x1 0) (x2 0) (y1 0) (y2 0) (acum 0) (nueva '()) (resultado '()))
    (setq y1 (length li1) y2 (length li2))
    (setq x1 (length (first li1)) x2 (length (first li2)))
    (cond ((/= y1 x2) nil)
      (T 
       (dotimes (y y2 (reverse resultado))     
          (setq nueva '() )
	  (setq nueva
	  (dotimes (x x1 (reverse nueva))
	    (setq acum 0 )
	    (setq acum
	    (dotimes (index y1 acum)
	      (setq acum (+ acum (* (nth x (nth index li1))
					(nth index (nth y li2)) )))
	    ))
	    (setq nueva (cons acum nueva))
	  ))
	  (setq resultado (cons nueva resultado))
        )
      )
    )
  )
)
