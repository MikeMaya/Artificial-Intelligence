(defun ElemInPos (elemento lista pos)
  (cond ((< pos 1) nil)
	((AND (null lista) (> pos 1)) nil)
	((AND (= 1 pos) (equal elemento (first lista))) T)
	(T (ElemInPos elemento (rest lista) (- pos 1)))
  )
)

(defun Inicia-en (lista elem) 
  (labels ((IniciaR (lis ele copia flag) 
    (cond ((null lis) (reverse copia)) ;se termina de procesar
           ((not (null flag)) ; ya se encontro
	    (IniciaR (rest lis) ele (cons (first lis) copia) flag)) 
	   ((equal ele (first lis)) ;es el primer elemento
	     (IniciaR (rest lis) ele (list (first lis)) T))
	   (T (IniciaR (rest lis) ele copia flag))
     )
   )) (IniciaR lista elem '() nil))
)

(defun Termina-en (lista elem) 
  (labels ((TerminaR (lis ele copia) 
    (cond ((null lis) nil) ;nunca se encontro
	  ((equal ele (first lis)) ;se termino
	   (reverse (cons (first lis) copia)))
	  (T (TerminaR (rest lis) ele (cons (first lis) copia)))
     )
   )) (TerminaR lista elem '()))  
)

(defun Primer-impar (lista)
  (labels ((ImparR (lis index)
    (cond ((oddp (first lis)) (list (first lis) index))
	  (T (ImparR (rest lis) (+ index 1)))
    )
  )) (ImparR lista 0))
)

(defun Ultimo-elemento (lista)
  (labels ( (UltimoR (lis contador elemento)
    (cond ((null lis) (list elemento contador))
      ((AND (null elemento)(realp (first lis))(plusp (first lis))) 
       (UltimoR (rest lis) 1 (first lis))
      )
      ((AND (not (null elemento)) (= elemento (first lis))) 
       (UltimoR (rest lis) (+ contador 1) elemento)
      )
      (T (UltimoR (rest lis) contador elemento))
    )
  ))(UltimoR (reverse lista) 0 nil))
)

(defun Conteo(lista)
  (labels ((ConteoR (lis L A)
    (cond ((null lis) (cons A L))
          ((listp (first lis)) (ConteoR (rest lis) (+ L 1) A))
	  ((numberp (first lis)) (ConteoR (rest lis) L (+ A 1)))
	  (T (ConteoR (rest lis) L A))
    )
  ))(ConteoR lista 0 0))
)

(defun Aplana (lista)
  (let ((copia '()) )
    (dolist (i lista (reverse copia))
      (cond ((listp i) (dolist (j (Aplana i) copia)
                        (setq copia (cons j copia))))
	    (T (setq copia (cons i copia)))
      )
    )
  )
)

(defun Diagonal (lista)
  (labels (( DiagonalR (lis pos res)
     (cond ((null lis) (reverse res))
	   (T (DiagonalR (rest lis) (+ pos 1) 
			 (cons (nth pos (first lis)) res)))
     )
   ))(DiagonalR lista 0 '()))
)

(defun Elementos (lista)
  (labels ((ElementosR (lis copia)
    (cond ((null lis) (reverse copia))
  	  ((AND (listp (first lis)) (null (first lis))) 
	   (ElementosR (rest lis) (cons 'N copia)))
	  ((listp (first lis)) (ElementosR (rest lis) (cons 'L copia)))
	  ((atom (first lis)) (ElementosR (rest lis) (cons 'A copia)))
    )
  ))(ElementosR lista '()))
)

(defun SumaNumerica (lista) 
  (labels (( SumaR (lis acum)
    (cond ((null lis) acum)
          ((numberp (first lis)) (SumaR (rest lis) (+ acum (first lis))))
	  (T (SumaR (rest lis) acum))
     )
  ))(SumaR lista 0))
)

(defun FiltraVocales (lista)
  (let ((copia '()) )
    (dolist (i lista (reverse copia))
      (cond ((listp i) (setq copia (cons (FiltraVocales i) copia)))
	    ((NOT (OR (equal #\A i)(equal #\a i)(equal #\E i)(equal #\e i) 
             (equal #\I i) (equal #\i i)(equal #\O i) (equal #\o i)  
	     (equal #\U i)  (equal #\u i))) (setq copia (cons i copia)))
      )
    )
  )
)

(defun FiltraMultiplos (lista multi)
  (let ((copia '()) )
    (dolist (i lista (reverse copia))
      (cond ((listp i) (setq copia (cons (FiltraMultiplos i multi) copia)))
	    ((AND (numberp i)(NOT (= (mod i multi) 0))) 
	     (setq copia (cons i copia)))
	    ((NOT (numberp i)) (setq copia (cons i copia)))
      )
    )
  )
)

(defun Celdas (lista) 
  (let ((tam (length lista)))
    (dolist (i lista tam) 
      (cond ((listp i ) (setq tam (+ tam (Celdas i)))))
    )
  )
)

(defun Implicacion (&rest lista)
  (labels ((ImpliR (lis result)
    (cond ((null lis) result)
	  ((AND (not (null result))(null (first lis))) (ImpliR (rest lis) nil))
	  (T (ImpliR (rest lis) T))
    )
  ))(ImpliR lista T))
)

(defun Mult (li1 li2)
  (let ((x1 0) (x2 0) (y1 0) (y2 0) (nueva '()) (resultado '()))
    (setq y1 (length li1) y2 (length li2))
    (setq x1 (length (first li1)) x2 (length (first li2)))
    (labels ( 
        (Mlinea (lista1 lista2)
	  (cond ((null lista1) 0) 
		 (t (+ (* (first lista1) 
		       (first lista2)) 
		       (Mlinea (rest lista1) (rest lista2))))))

	(Nthimos (n lista) 
	  (cond ((null lista) '() ) 
		(T (cons (nth n (first lista)) (Nthimos n (rest lista))))))
	
	(MultR (m1 m2)
	  (cond ((/= y1 x2) nil)
		(T 
	     (dotimes (y y2 (reverse resultado))     
	       (setq nueva '() )
	       (setq nueva
		 (dotimes (x x1 (reverse nueva))
		   (setq nueva (cons (Mlinea (Nthimos x m1)(nth y m2)) nueva))
		  ))
	        (setq resultado (cons nueva resultado))
	     )))
	))(MultR li1 li2)
    ) 
  )
)

(defun FindN (lista elem)
  (cond ((null lista) nil)
        ((equal elem (first lista)) lista)
	(t (FindN (rest lista) elem))
  )
)

(defun Cambia (lista elem1 elem2)
  (labels ((CambiaR (lis e1 e2 copia)
     (cond ((null lis) (reverse copia))
	   ((equal e1 (first lis)) (CambiaR (rest lis) e1 e2 (cons e2 copia)))
	   (T (CambiaR (rest lis) e1 e2 (cons (first lis) copia)))
    )
   ))(CambiaR lista elem1 elem2 '())))

(defun fib (n)
  "Naive recursive computation of the nth element of the Fibonacci sequence"
  (check-type n (integer 0 *))
  (if (< n 2) n
      (+ (fib (1- n)) (fib (- n 2)))))

(defun fib1 (n)
	  "Tail-recursive computation of the nth element of the Fibonacci sequence"
	  (check-type n (integer 0 *))
	  (labels ((fib-aux (n f1 f2)
	                    (if (zerop n) f1
	                      (fib-aux (1- n) f2 (+ f1 f2)))))
	          (fib-aux n 0 1)))

(defun fib2 (n)
	  "do-based iterative computation of the nth element of the Fibonacci sequence"
	  (check-type n (integer 0 *))
	  (do ((i n (1- i))
	       (f1 0 f2)
	       (f2 1 (+ f1 f2)))
	      ((= i 0) f1)))

(defun fib3 (n)
  "CPS computation of the nth element of the Fibonacci sequence"
  (check-type n (integer 0 *))
  (labels ((fib-aux (n k)
                    (if (zerop n)
                        (funcall k 0 1)
                      (fib-aux (1- n) (lambda (x y)
                                        (funcall k y (+ x y)))))))
          (fib-aux n #'(lambda (a b) a))))

(defun fib4 (n)
   (labels ((fib2 (n)
                 (cond ((= n 0)
                        (values 1 0))
                       (t
                        (multiple-value-bind (val prev-val)
                                             (fib2 (- n 1))
                           (values (+ val prev-val)
                                   val))))))
      (nth-value 0 (fib2 n))))

(defun fib5 (n)
  "Successive squaring method from SICP"
  (check-type n (integer 0 *))
  (labels ((fib-aux (a b p q count)
                    (cond ((= count 0) b)
                          ((evenp count)
                           (fib-aux a
                                    b
                                    (+ (* p p) (* q q))
                                    (+ (* q q) (* 2 p q))
                                    (/ count 2)))
                          (t (fib-aux (+ (* b q) (* a q) (* a p))
                                      (+ (* b p) (* a q))
                                      p
                                      q
                                      (- count 1))))))
          (fib-aux 1 0 0 1 n)))

(defun fib6 (n)
  (if (< n 2) n
    (if (oddp n) 
      (let ((k (/ (1+ n) 2)))
        (+ (expt (fib k) 2) (expt (fib (1- k)) 2)))
      (let* ((k (/ n 2)) (fk (fib k)))
        (* (+ (* 2 (fib (1- k))) fk) fk)))))

;;;Original code by Arnold Schoenhage, 
;;;translated to Scheme by Bradley J. Lucier (2004), 
;;;and adapted to Common Lisp by Nicolas Neuss.
(defun fast-fib-pair (n)
  "Returns f_n f_{n+1}."
  (case n
    ((0) (values 0 1))
    ((1) (values 1 1))
    (t (let ((m (floor n 2)))
         (multiple-value-bind (f_m f_m+1)
             (fast-fib-pair m)
           (let ((f_m^2   (* f_m f_m))
                 (f_m+1^2 (* f_m+1 f_m+1)))
             (if (evenp n)
                 (values (- (* 2 f_m+1^2)
                            (* 3 f_m^2)
                            (if (oddp m) -2 2))
                         (+ f_m^2 f_m+1^2))
                 (values (+ f_m^2 f_m+1^2)
                         (- (* 3 f_m+1^2)
                            (* 2 f_m^2)
                           (if (oddp m) -2 2))))))))))
;; Fibonacci - Binet's Formula
(defun fib7 (n)
  (* (/ 1 (sqrt 5))
     (- (expt (/ (+ 1 (sqrt 5)) 2) n)
	(expt (/ (- 1 (sqrt 5)) 2) n))))

(defun fib8 (n)
  (/ (- (expt (/ (+ 1 (sqrt 5)) 2) n)
        (expt (/ (- 1 (sqrt 5)) 2) n))
     (sqrt 5)))


(defun Mapea (funcion &rest lista)
  (let ((flag T) (cade1 '()) (cade2 '())) 
    (setq flag (dolist (i lista flag) ;si ya termino alguna lista pone nil
		 (cond ((null i) (setq flag nil))
		       (T (setq cade1 (cons (first i) cade1) 
				cade2 (cons (rest i) cade2))))))
    (cond ((null flag) '())
	  (T (cons (apply funcion cade1) 
		   (apply #'Mapea (cons funcion cade2) )
	     )
	  )
    )
  )
)

(defun Elimina (lista elem)
  (labels (( EliminaR (lis el copia)
     (cond ((null lis)(reverse copia))
           ((AND (numberp (first lis)) (> (first lis) el)) 
	    (EliminaR (rest lis) el (cons (first lis) copia)))
	   (T (EliminaR (rest lis) el copia))
     )
  ))(EliminaR lista elem '())
  )
)

(defun PegaYCopia (lista1 lista2 elem1 elem2)
  (labels ((CambiaR (lis e1 e2 copia)
     (cond ((null lis) copia)
	   ((equal e1 (first lis)) (CambiaR (rest lis) e1 e2 (cons e2 copia)))
	   (T (CambiaR (rest lis) e1 e2 (cons (first lis) copia)))
     )))(reverse (CambiaR lista2 elem1 elem2 (CambiaR lista1 elem1 elem2 '())))) 
)


(defun quicksort (lista)
  ;;Utilizo un arreglo auxiliar para facilitar acceso
  ;;En el arreglo meto los numericos
  ;;Aplico quicksort sobre el arreglo y al final lo uno a los no numericos
  (let ((elem 0) (arreglo nil) (res '()) (nums '()))
	(dolist (i lista elem)
   	  (cond ((numberp i) (setq elem (+ elem 1) nums (cons i nums)))
		 (T (setq res (cons i res)))))
	(setq nums (reverse nums) arreglo (make-array elem) elem 0)
	(dolist (i nums arreglo)
	         (setf (aref arreglo elem) i) 
		 (setq elem (+ elem 1)))
	(qsort arreglo 0 (- elem 1))
	(setq nums '())
	(loop for i from 0 to (- elem 1) do
	     (setq nums (cons (aref arreglo i) nums))
	)
	(setq res (append (reverse nums) (reverse res)))
  )	
)

(defun qsort (arreglo inicio fin)
  ;;tomo como pivote el elemento final
  ;;aplico a la mitad inferior y superior
  (let ((middle 0))
    (cond ((< inicio fin)
      (setq middle (particion arreglo inicio fin))
      (qsort arreglo inicio (- middle 1))
      (qsort arreglo (+ middle 1) fin)
     ))
  )
)

(defun particion (arreglo lo hi)
  ;;cambio los elementos antes del pivote
  (let ((x (aref arreglo hi)) (i (- lo 1)) (aux 0))
    (loop for j from lo to hi  
       do (cond ( (< (aref arreglo j) x) 
		 (setq i (+ i 1)) 
		 (setq aux (aref arreglo i))
		 (setf (aref arreglo i) (aref arreglo j))
		 (setf (aref arreglo j) aux) )
	   )
	  
    )
    (setq aux (aref arreglo (+ i 1)))
    (setf (aref arreglo (+ i 1)) (aref arreglo hi))
    (setf (aref arreglo hi) aux)
    (return-from particion (+ i 1))
 )
)
